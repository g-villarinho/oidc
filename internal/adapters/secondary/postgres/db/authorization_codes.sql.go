// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: authorization_codes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuthorizationCode = `-- name: CreateAuthorizationCode :one
INSERT INTO authorization_codes (
    code,
    client_id,
    user_id,
    redirect_uri,
    scopes,
    code_challenge,
    code_challenge_method,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING code, client_id, user_id, redirect_uri, scopes, code_challenge, code_challenge_method, used, expires_at, created_at
`

type CreateAuthorizationCodeParams struct {
	Code                string           `json:"code"`
	ClientID            string           `json:"client_id"`
	UserID              pgtype.UUID      `json:"user_id"`
	RedirectUri         string           `json:"redirect_uri"`
	Scopes              []string         `json:"scopes"`
	CodeChallenge       pgtype.Text      `json:"code_challenge"`
	CodeChallengeMethod pgtype.Text      `json:"code_challenge_method"`
	ExpiresAt           pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateAuthorizationCode(ctx context.Context, arg CreateAuthorizationCodeParams) (AuthorizationCode, error) {
	row := q.db.QueryRow(ctx, createAuthorizationCode,
		arg.Code,
		arg.ClientID,
		arg.UserID,
		arg.RedirectUri,
		arg.Scopes,
		arg.CodeChallenge,
		arg.CodeChallengeMethod,
		arg.ExpiresAt,
	)
	var i AuthorizationCode
	err := row.Scan(
		&i.Code,
		&i.ClientID,
		&i.UserID,
		&i.RedirectUri,
		&i.Scopes,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.Used,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAuthorizationCode = `-- name: DeleteAuthorizationCode :exec
DELETE FROM authorization_codes
WHERE code = $1
`

func (q *Queries) DeleteAuthorizationCode(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, deleteAuthorizationCode, code)
	return err
}

const deleteExpiredAuthorizationCodes = `-- name: DeleteExpiredAuthorizationCodes :exec
DELETE FROM authorization_codes
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredAuthorizationCodes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAuthorizationCodes)
	return err
}

const getAuthorizationCode = `-- name: GetAuthorizationCode :one
SELECT 
    ac.code, ac.client_id, ac.user_id, ac.redirect_uri, ac.scopes, ac.code_challenge, ac.code_challenge_method, ac.used, ac.expires_at, ac.created_at,
    c.client_id as client_client_id,
    c.redirect_uris as client_redirect_uris,
    u.email as user_email
FROM authorization_codes ac
JOIN oauth_clients c ON ac.client_id = c.client_id
JOIN users u ON ac.user_id = u.id
WHERE ac.code = $1 
  AND ac.expires_at > NOW()
LIMIT 1
`

type GetAuthorizationCodeRow struct {
	Code                string           `json:"code"`
	ClientID            string           `json:"client_id"`
	UserID              pgtype.UUID      `json:"user_id"`
	RedirectUri         string           `json:"redirect_uri"`
	Scopes              []string         `json:"scopes"`
	CodeChallenge       pgtype.Text      `json:"code_challenge"`
	CodeChallengeMethod pgtype.Text      `json:"code_challenge_method"`
	Used                bool             `json:"used"`
	ExpiresAt           pgtype.Timestamp `json:"expires_at"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	ClientClientID      string           `json:"client_client_id"`
	ClientRedirectUris  []string         `json:"client_redirect_uris"`
	UserEmail           string           `json:"user_email"`
}

func (q *Queries) GetAuthorizationCode(ctx context.Context, code string) (GetAuthorizationCodeRow, error) {
	row := q.db.QueryRow(ctx, getAuthorizationCode, code)
	var i GetAuthorizationCodeRow
	err := row.Scan(
		&i.Code,
		&i.ClientID,
		&i.UserID,
		&i.RedirectUri,
		&i.Scopes,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.Used,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.ClientClientID,
		&i.ClientRedirectUris,
		&i.UserEmail,
	)
	return i, err
}

const markAuthorizationCodeAsUsed = `-- name: MarkAuthorizationCodeAsUsed :exec
UPDATE authorization_codes
SET used = TRUE
WHERE code = $1
`

func (q *Queries) MarkAuthorizationCodeAsUsed(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, markAuthorizationCodeAsUsed, code)
	return err
}
